[ 4. 알고리즘 ]
< 1) 검색 알고리즘 >
먼저 주어진 배열 속에서 특정 값을 찾는 방법부터
시작해 보겠다.
- 선형 검색, 이진 검색

- 배열
: 한 자료형의 여러 값들이 메모리상에 모여 있는 구조.

- 선형 검색
: 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서
방문하여 그 값이 속하는지를 검사.

- 이진 검색
: 만악 배열이 정렬되어 있다면, 매열 중간의 인덱스부터
시작하여 찾고자 하는 값과 비교하며 그보다 작은 값이 있는
인덱스 or 큰 값이 있는 인덱스로 이동을 반복하면 된다.

======================================
< 2) 알고리즘 표기법 >
알고리즘의 실행 시간의 상한과 하한을 표기할 수 있게된다.
- 실행시간의 상한 (Big O) : 제일 시간 오래걸리는거 ( O는 on the order of)
- 실생시간의 하한 (Big Ω) : 빠른거

====================================
< 3) 선형 검색 >
- 주어진 배열에서 선형 검색으로 값을 찾는 방법을 알아보자.
한 배열의 특정 속성값을 찾고 동일한 위치의 다른 배열의
속성값을 출력하는 방법도 배워보자.
또, 이를 더 간단하고 확장성있게 구현하는 법을 배워보자.
- 주어진 배열 or 구조체에서 선형 검색을 할 수 있다.
- 선형 검색, 구조체

- 선형 검색
: 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지
차례대로 검색.

- 효율성 and 비효율성
: '선형 검색 알고리즘'은 정확하지만, 효율 X
 선형검색은, 자료가 정렬 X or 어떤 정보도 없어 하나씩 찾아야 할 때 유용.
=> 이 것을 보면 왜 검색 이전에 정렬을 해줘야 하는지 알 수 있다.
 정렬은 시간이 오래걸리고 공간을 더 차지하지만,
 정렬을 하면 매우 큰 리스트를 검색할때 더 빨리진다.

- 구조체
string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};
은 서로 같은 인덱스를 가져야 사용할 수 있다. 그래서 편하게 사용하기 위해,
새로운 자료형으로 구조체를 정의해서 이름 & 번호를 묶을 수 있다.
=> 
typedef struct
{
    string name;
    string number;
}
person;

==========================================
< 4) 버블 정렬 >
어떤 배열이 주어졌을 때, 그 배열이 미리 정렬되어 있다면
훨씬 빠른 속도로 검색이 가능하다.
버블 정렬의 원리와 실행시간을 설명하고 구현할 수 있게된다.

- 버블 정렬
: 두개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬.

==========================================
< 5) 선택 정렬 >
: 선택 정렬은, 배열 안의 자료 중 가장 작은 수(or 가장 큰 수)를
 찾아 첫 번째 위치(or 마지막 위치)의 수와 교환해주는 방식의
 정렬이다.
  선택 정렬은, 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가.

===========================================
< 6) 정렬 알고리즘의 실행시간 >
여태까지 배운 선형 검색, 이진 검색, 버블 정렬, 선택 정렬의
실행시간이 각각 어떻게 되는지 정리해 보겠다.

==========================================
< 7) 재귀 >
알고리즘 구현 위해 코드를 작성하다 보면 동일한 작업을
반복해야 할 때가 있다. 이러한 작업을 함수로 구현하면
코드를 보다 효율적으로 만들 수 있음을 배웠다.
하지만, 함수 내에서도 동일한 작업이 반복되는 경우는 어떨까?
이번 강의는 함수를 함수 내에서 재사용하는 방법, 
즉 재귀적으로 호출하는 방법을 배워 보겠다.

- 재귀
: 함수가 본인 스스로를 호출해서 사용할 수 있다라는 점에서
이것을 재귀(Recursion)이라고 부른다.

=========================================
< 8) 병합 정렬 >
재귀를 활용한 병합 정렬을 구현할 수 있습니다.

- 병합 정렬(합병 정렬)
: 원소가 한 개가 될 때까지 계속해서 반으로 나누다가
 다시 합쳐나가며 정렬을 하는 방식.

상한(최악의 경우) : O(n log n)
하한(최선의 경우) : Ω(n log n)
=> 이 상한 == 하한 이라면 >>  θ(n log n)

=========================================
< Quiz 틀린거 오답노트 >
#6. 
선택정렬, 버블정렬, 선형검색, 이진검색 4가지알고리즘이
최선인경우일때의실행시간이(하한) 빠른순서 대로나열한것은
무엇인가요? (단, 하한이같은경우상한이빠른순으로나열합니다.)
=> 
Ω(1): 선형검색, 이진검색 < Ω(n): 버블정렬 < Ω(n^2): 선택정렬
O(log n): 이진검색 < O(n): 선 형검색 < O(n^2): 선택정렬, 버블정렬

#8
아래코드와같이피라미드쌓기를재귀적으로작성한코드에서, 
h 값으로 3이입력되었을때 draw 함수는총 몇번호출될까요? 
=>
h 값이 3인경우, 3일때, 2일때, 1일때총 3번호출되며총 3층이쌓이게됩니다

#9
병합정렬, 선택정렬, 버블정렬의실행시간의하한을빠른순서대로정렬한것은무엇인가요?
=>
Ω(n): 버블정렬 < Ω(n log n): 병합정렬 < Ω (n^2): 선택정렬.

#10
다음 Big-O 표기법중빠른순서대 로올바르게정렬한것은무엇인가요?
=>
Big-O 표기법은알고리즘의실행시간이 n에따라변화하는정도를나타낸것입니다
1 < log n < n < nlog n < n^2 














